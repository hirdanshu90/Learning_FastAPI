# from fastapi import FastAPI, Query, Path
# from enum import Enum
# from pydantic import BaseModel


# app = FastAPI()

@app.get("/")
async def root():
    return {"message": "hello world"}


@app.post("/")
async def post():
    return {"message": "hello from post route"}

@app.put("/")
async def put():
    return {"message": "hello from put route"}


fake_items_db = [{"item_name": "foo"},{"item_name": "bar"},{"item_name": "Hel"},{"item_name": "yeso"},{"item_name": "Nahh"}]

@app.get("/items")
async def list_itmes(skip:int = 0, limit:int = 10):
    return fake_items_db[skip:skip+limit]

@app.get("/items/{item_id}")
async def get_item(item_id: str, q: str | None = None, short : bool = False):
    item = {"item_id": item_id}
    if q:
        item.update({"q":q})
    if not short:
        item.update(
            {      
                "description": "Some random stuff to update"
            }
        )
    return item


# Can have multiple queries in the same get api. URL here will be - http://127.0.0.1:8001/items/foo/users/1?q=hey_there&short=True
@app.get("/items/{item_id}/users/{user_id}")
async def get_user_item(user_id:int, item_id:str, q: str|None = None, short: bool = False):
    item = {"item_id": item_id, "user_id":user_id}
    if q:
        item.update({"q":q})
    if not short:
        item.update({
            "description": "some random stuff"
        })
    return item



class FoodEnum (str, Enum):
    fruits = "fruits"
    vegetables = "vegetables"
    dairy = "dairy"
    
    
@app.get("/foods/{food_name}")
async def get_food(food_name: str):
    if food_name == "vegetables":
        return {"message": "you are healthy"}
    elif food_name == "fruits":
        return {"message": "you are still healthy, eating fruits"}
    else:
        return {"message": "Drinking dairy here, why ........."}


#  /////////////////////////////////////////// Request Body///////////////// V4 ////////////////////////////////////

class Item(BaseModel):
    name: str
    description:str |None = None
    price : float
    tax: float | None = None
    

@app.post("/items")
async def create_item(item: Item) -> dict:
    item_dict = item.model_dump()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict



@app.put("/item/{item_id}")
async def create_item_with_put(item_id:int, item:Item, q: str| None = None):
    result =  {"item_id":item_id, **item.model_dump()}
    if q:
        result.update({"q": q})
    return result
    
#  ///////////////////////// Query parameters and Str Validation ///////////////// V5 ////////////////////

@app.get("/items_string_validation")
async def create_string_validation(q:str|None = Query(None, min_length=3, max_length=100)):
    result = {"items": [{"items+id": "Foo"}, {"item_id":"Bar"}]}
    if q:
        result.update({"q":q})
    return result


@app.get("/items_validation/{item_id}")
async def read_items_validation(*, items_id: int = Path(..., title="The ID of the item to get"), q: str |None = Query(None, alias="items-query")):
    results = {"items_id": items_id}
    if q:
        results.update({"q":q})
    return results

# ///////////////////////////  Body - Multiple Parameters /////////////////////////////  V7

